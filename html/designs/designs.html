<!DOCTYPE html>
<head>
    <title>Architecture and Design</title>
    <link rel="icon" type="image/x-icon" href="../../img/swlayer.png">
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Payments</title>
</head>
<style>
    body {
        background-image: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url('../../img/curves.jpg');
        width:100vw;
        background-position: left;
        background-repeat: 1;
        background-size: cover;
        position: page;
        object-fit: fill;
        min-width: 50vw;
        min-height: 50vw;
    }

    @media (min-width: 400px) {
        p1 { font-size: 4vw; color: wheat; margin-left: 8vw; }
        p2 { font-size: 2vw; color: wheat; margin-left: 0vw; }
        p3 { font-size: 1.5vw; color: greenyellow; }
    }

    @media (max-width: 399px) {
        p1 { font-size: 10vw; color: wheat; margin-left: 2vw; }
        p2 { font-size: 5vw; color: wheat; }
        p3 { font-size: 4vw; color: greenyellow; }
    }

    .container {
        position:center;
    }

    @media (min-width: 400px) {
        .text-block {
            font-size: 1.5vw;
            color: white;
            position: absolute;
            margin-left: 8vw;
            margin-right: 25vw;
            width: 70vw;
            text-align: justify;
         }
    }

    @media (max-width: 399px) {
        .text-block {
            font-size: 4vw;
            color: white;
            position: absolute;
            margin-left: 3vw;
            margin-right: 2vw;
            width: 90vw;
            text-align: justify;
         }
    }

    .logo {
        width: 20vw;
    }

    .portrait {
        position: absolute;
        width: 15vw;
        height: 15vw;
        top: 0vw;
        right: 3vw;
        border-radius: 20vw;
        margin-top: 0vw;
        margin-left: 80vw;
    }

    @media (max-width: 399px) {
        .float {
            float: left;
            margin-top: 2vw;
            margin-bottom: 2vw;
            margin-right: 3vw;
            width: 90vw
        }
    }

    @media (min-width: 400px) {
        .float {
            float: left;
            margin-top: 2vw;
            margin-bottom: 2vw;
            margin-right: 3vw;
            width: 50vw
        }
    }

    a:hover{opacity:0.5;}

</style>
<html>
<body>
    <div class="container">
        <div><p1>Software architecture and design</p1></div>
        <img class = portrait src="../../img/interrupt.jpg" alt="Clock" padding-bottom="5vw">
        <div class="text-block">
            <div><hr>
                <p2>Introduction</p2><hr>
                The following is an overview of the design techniques and philosophies I have evolved over time while working
                a number of projects from adding features to complete ground up new development. They apply to new features
                and products only. It is not advisable to apply them when modifying existing code or fixing bugs. My approach to this
                is outlined in my software maintenance description.<hr><br>

                <p2>Top down design pitfalls<br></p2><hr>
                Early on in the field Embedded Software development processors were small and lacked resource. The developers came
                from electronics backgrounds. They were typical engineers who approached problem solving with a top-down perspective.
                Attempts were made to gleen as much use of memory as possible. This resulted in extensive re-use of RAM and global variables.
                Stack size was small and jumps backwards and forwards throughout code was common. This introduced a tendency for 'spaghetti' logic.
                Functions were long and cumbersome and served multiple purposes whose side-effects were frequently difficult to characterise.
                There was no concept of multiple threads and hence it was not uncommon to add code and find large latencies occurring in the
                code that was already there. There was very little concept of layering and often interrupts were heavily overloaded with
                unnecessary functionality in order to offset these latencies. Modularity was beginning to be a recognised concept but this only served to
                group 'like code' with 'like functionality'. It added readability but the realtime performance was still often compromised.
                <br><br>
                <p2>Bare metal and Round Robin scheduling<br></p2> <hr>
                Early embedded code was executed in a single loop (round robin) and no thought was given to the realtime priority of
                specific tasks. Hence, UI updates occurred within the same timeframe as realtime data processing (often updated via
                interrupt functions). In my experience this resulted in the absurd symptom of button presses being processed
                too slowly, and their associated sounds and LED updates lagging accordingly. Meanwhile, timers and ADC interrupts were going
                unserviced for, what relatively speaking, was millenia.
                <br><br>
                <p2>Modularity and reusability<br></p2><hr>
                Modularity was a way of introducing the idea that functions should only perform one task. It meant that it could be
                easily recognised and maintained without necessary knowledge of it's clients. This added readability, maintainability and
                portability between platforms. It seems obvious but so often I find code today performing more than one duty whose side
                effects need to be considered when modifying it. Alongside this concept came another of data encapsulation. Data corruption
                was a very common problem. Squeezing data down into the location where it is actually used helped to do away with global
                variables. It forced the programmer to think carefully about the data but this was a necessary effort to make. Taking a
                'step back' and really considering the purpose of it and considering things such as:
                <ul>
                <li>Who owns it?</li>
                <li>Should it retain its value?</li>
                <li>Can it be modified?</li>
                <li>Where is it located?</li>
                <li>Who has access to it?</li>
                <li>What is its real purpose?</li>
                </ul>
                <br>
                <p2>Idle time and interrupts</p2><hr>
                Processors should spend 90% of their time <u>doing nothingu</u>. In an event driven system the software should only spring into 
                action when an interrupt occurs. Striving for this in software designs should be the goal of any architect. When interrupts occur, 
                they should be short and quick. They should do very little except modify data. This data can be monitored at leisure externally 
                by a 'loop'. This can involve multiple 'loops' all running at varying priorities and rates depending on the rate of change of their 
                respective modified data. They also should be as short as possible so as not to take to much processor bandwidth.
                An example of a low priority slow task is the updating of a display. An example of a high priority fast task is the reading of a
                button press. Both of these are related to the UI but both exist at opposite ends of the software 'stack'.<br><br>

                <p2>Software layering and scheduling tasks<br></p2><hr>
                A overview of how to structure a basic software architecture can be illustrated in the following block diagram.
                It is a very simplistic view and can be expanded on an application by application basis. It is how I approach a software architecture and bring 
                in other concepts as necessary. It can lend itself to porting an OS if necessary to allow inter-task messaging and pre-emption.                
                <img class=float src="../../img/layers.jpg" alt="Clock" padding-bottom="5vw" padding-right="10vw">
                Each block represents a thread which is executed at a rate determined by the scheduler and its task table. Generally the higher
                the block is in the system the slower the rate at which it runs. A high resolution timer is used  as a system tick that parses the 
                table updating the individual task ticks. Each thread should be kept as short as possible so as to allow the execution of the following thread.
                Interrupts occur outside the scheduler and update driver data in realtime. This data is then parsed, conditioned and manipulated by the core task 
                associated with it. This may involve averaging and bounds checking, for example. Once the data is in a usable state, the associated application
                accesses it and makes decisions as to how the system should behave. It is here that multiple objects and classes may reside. State machines 
                exist here and are transitioned by events coming from the interrupt layer and any change in data from the core layer. Any control is exerted 
                either via HW drivers (e.g. USART, I2C interfaces) or direct GPIO (relays, switches etc).<br><br>
                <p2>State machines, events and interrupts<br></p2>
                Wherever possible, I am an advocate of state machines for each object. The philosphy is that each object in the software has a direct corresponding 
                relationship with an object in the 'real world'. Hence its behaviour should match the behaviour of the 'real world' object. I avoid using 'flags'
                at all costs as the need to add a flag is an indication that there is actually another state that hasn't been implemented.<br><br>
                The state machine should only change state when an event occurs, otherwise it should be doing nothing (ref. 'Idle time and interrupts' above).
                These events should be generated either directly or indirectly via interrupt or change of state of a neighbouring task. I dislike and avoid polling
                of any kind as this creates a processor overhead that (as mentioned) 90% of the time results in nothing happening.<br><br>
                <p2>Objects and the real world<br></p2><hr>
                A software architecture is made of multiple domains. A precursor to designing should be a domain analysis. In the diagram above we can see that the 
                user interface block can consitute a domain which we can analyse. Within it we may observe that it can comprise real world objects such as button(s), 
                display(s), sound(s)s. Each of these can can have their own states. Below these objects can be core objects which hold data related to these objects.
                A way to think of these is to attempt to restrict any concept of the data from knowledge of the object they supply. For example, a button will have
                states of 'pressed', 'released', 'toggled', 'long press'. The core object will hold the values of the button state in units such as voltage or current.
                Timing functions can reside insde these core objects to determine the events to pass to the UI object. They can perform debouncing, thresholds 
                and sample history. Below these are the driver objects. These are specific to the hardware platform being used. They have knowledge of the IO to sample.
                They have knowledge of the interrupts to configure and respond to. When interrupts occur, the hardware drivers process the interrupt and read any 
                data provided. For example, an ADC interrupt trigger can signal to the driver that a reading is available to be sampled and made available to the core 
                object.<br><br>
                <br><br>                
            </div>
        </div>
    </div>
</body>
</html>
</body>
</html>

